package animationtest;

import java.io.*;
import java.util.Calendar;
import java.util.LinkedList;
import java.util.Scanner;

import static animationtest.ProgramInfo.ItemData;

public class Export {

    public static void writeTextFile(String code, String filePath) throws FileNotFoundException {
        PrintWriter outFile = new PrintWriter(filePath);

        outFile.write(code);
        outFile.close();
    }

    public static void writeBinaryFile(String fileName, PointArray pointArray) throws IOException {
        FileOutputStream fos = new FileOutputStream(fileName);
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeInt(pointArray.size());
        for (Point p : pointArray.getList()) {
            oos.writeObject(p);
        }
    }

    public static String pointArrayToString(PointArray pointArray) {
        String out = "";

        for (int i = 0; i < pointArray.size(); i++) {
            out += pointArray.get(i).toString() + "\n";
        }

        return (out);
    }

    private static PointArray fileToPoints(File f) {
        PointArray rtn = new PointArray();
        Scanner scan;

        try {
            scan = new Scanner(f);

            String aPoint;

            double x, y;
            String code;
            int speed;

            //as long as there are more points
            while (scan.hasNextLine()) {
                //put the line with the next point in a string for processing.
                aPoint = scan.nextLine();

                //extract the information about the point from the string
                x = Double.parseDouble(aPoint.substring(2, aPoint.indexOf(' ')));
                aPoint = aPoint.substring(aPoint.indexOf(' ') + 1);
                y = Double.parseDouble(aPoint.substring(2, aPoint.indexOf(' ')));
                aPoint = aPoint.substring(aPoint.indexOf('\"') + 1);
                code = aPoint.substring(0, aPoint.indexOf('\"'));
                aPoint = aPoint.substring(aPoint.indexOf('[') + 1);
                speed = Integer.parseInt(aPoint.substring(0, aPoint.indexOf(']')));

                //make a new point with the information extracted
                rtn.add(new Point(x, y, code, speed));
            }

            scan.close();
        } catch (FileNotFoundException e) {
            System.out.print("file not found!");
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.out.print("Illegal file format!");
            e.printStackTrace();
            rtn.clear();
        } finally {
            return rtn;
        }
    }

    public static PointArray readTextFile(String path) {
        return fileToPoints(new File(path));
    }

    public static PointArray readBinaryFile(String path) {
        PointArray rtn = new PointArray();

        try {
            FileInputStream fis = new FileInputStream(path);
            ObjectInputStream ois = new ObjectInputStream(fis);

            int size = ois.readInt();

            for (int i = 0; i < size; i++) {
                rtn.add((Point) ois.readObject());
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        return rtn;
    }

    /*public static String writeOpMode(ProgramInfo info) {
        String rtn = "";
        String user = System.getProperty("user.name");

        rtn += "package com.qualcomm.ftcrobotcontroller.opmodes;\n" +
                "\n" +
                "import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n" +
                "import com.qualcomm.robotcore.hardware.DcMotor;\n" +
                "import com.qualcomm.robotcore.hardware.Servo;\n" +
                "\n" +
                "*/

    /**\n" +
                " * This op mode was generated by FTC-autoDrawer.\n" +
                " * Code generated from file " + info.getSaveLocation().toString() + ", \n" +
                " * on " + Calendar.getInstance().getTime().toString() + ",\n" +
                " * by " + user + ".\n" +
                " * \n" +
                " * Insert your own documentation here\n" +
     " *//*\n" +
                "\n\n";

        rtn += "public class " + info.getProgramName() + " extends OpMode { \n\n";

        rtn += "    private final Boolean syncLock = true;\n\n";

        for (ItemData data : info.getMotors()) {
            rtn += "    DcMotor " + data.getProgramName() + ";\n";
            rtn += "    volatile double " + data.getProgramName() + "Power;\n";
        }

        for (ItemData data : info.getServos()) {
            rtn += "    Servo " + data.getProgramName() + ";\n";
            rtn += "    volatile double " + data.getProgramName() + "Position;\n\n";
        }

        rtn += "    public void start() {\n";

        for (ItemData data : info.getMotors()) {
            rtn += "        " + data.getProgramName() + " = hardwareMap.dcMotor.get(\"" + data.getControllerName() + "\");\n";
            if (data.isReversed())
                rtn += "        " + data.getProgramName() + ".setDirection(DcMotor.Direction.REVERSE);\n";
            rtn += "        " + data.getProgramName() + "Power = 0;\n";
        }

        rtn += "\n";

        for (ItemData data : info.getServos()) {
            rtn += "        " + data.getProgramName() + " = hardwareMap.servo.get(\"" + data.getControllerName() + "\");\n";
            if (data.isReversed())
                rtn += "        " + data.getProgramName() + ".setDirection(Servo.Direction.REVERSE);\n";
        }

        rtn += "    }\n\n";

        rtn += "    public void loop() {\n" +
                "        synchronized (syncLock) {\n";

        for (ItemData data : info.getMotors()) {
            rtn += "            " + data.getProgramName() + ".setPower(" + data.getProgramName() + "Power);\n";
        }

        for (ItemData data : info.getServos()) {
            rtn += "            " + data.getProgramName() + ".setPosition(" + data.getProgramName() + "Position);\n";
        }

        rtn += "        }\n" +
                "    }\n\n" +
                "    public void stop() {\n\n" +
                "    }\n" +
                "\n" +
                "    //This class keeps track of what the robot needs to do. \n" +
                "    //You need to make sure that methods autoDrive and autoTurn move the correct motors." +
                "    private class " + info.getProgramName() + "Thread extends Thread {\n" +
                "\n" +
                "        @Override\n" +
                "        public void run() {\n" +
                "            super.run();\n" +
                "\n";

        PointArray points = info.getPointArray();

        if (points.get(0).extraCode != null)
            rtn += "            " + points.get(0).extraCode + "\n";
        for (int i = 0; i < points.size() - 2; i++) {
            rtn += "            autoDrive(" + points.getDistance(i) + ");\n";
            if (points.get(i + 1).extraCode != null)
                rtn += "            " + points.get(i + 1).extraCode + "\n\n";
            rtn += "            autoTurn(" + points.getAngle(i + 1) + ");\n";
        }
        rtn += "            autoDrive(" + points.getDistance(points.size() - 2) + ");\n";
        if (points.get(points.size() - 1).extraCode != null)
            rtn += "            " + points.get(points.size() - 1).extraCode + "\n\n";

        rtn += "        }\n" +
                "\n" +
                "        private void autoDrive(double inches){\n" +
                "            synchronized (syncLock){\n" +
                "                //set motors here\n" +
                "            }\n" +
                "\n" +
                "            //wait code\n" +
                "\n" +
                "            synchronized (syncLock) {\n" +
                "                //stop motors here\n" +
                "            }\n" +
                "        }\n" +
                "\n" +
                "        private void autoTurn(double degrees){\n" +
                "            synchronized (syncLock){\n" +
                "                //set motors here\n" +
                "            }\n" +
                "\n" +
                "            //wait code\n" +
                "\n" +
                "            synchronized (syncLock){\n" +
                "                //stop motors here\n" +
                "            }\n" +
                "        }\n" +
                "    }\n" +
                "}";

        return rtn;
    }*/

    public static String writeLinearOpMode(ProgramInfo info) {
        String rtn = "";
        String user = System.getProperty("user.name");

        rtn += "package com.qualcomm.ftcrobotcontroller.opmodes;\n" +
                "\n" +
                "import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n" +
                "import com.qualcomm.robotcore.hardware.DcMotor;\n" +
                "import com.qualcomm.robotcore.hardware.DcMotorController;" +
                "import com.qualcomm.robotcore.hardware.Servo;\n" +
                "\n" +
                "/**\n" +
                " * This op mode was generated by FTC-autoDrawer.\n" +
                " * Code generated from file " + info.getSaveLocation().toString() + ", \n" +
                " * on " + Calendar.getInstance().getTime().toString() + ",\n" +
                " * by " + user + ".\n" +
                " * \n" +
                " * Insert your own documentation here\n" +
                " */\n" +
                "\n\n";

        rtn += "public class " + info.getProgramName() + " extends LinearOpMode { \n\n";

        //defining some named constants
        rtn += "    final int ENCODER_COUNTS_PER_ROTATION = 1440; // 1440 for tetrix motor encoders, 1120 for andymark neverest 40 encoders\n" +
                "    final double INCHES_PER_ROTATION =  Math.PI * " + info.getWheelDiameter() + " * " + ProgramInfo.getGearRatio() + ";\n" +
                "    double driveSpeed = 1; //must be between 0 and 1, this is the speed the motors will drive at\n\n";

        rtn += "    //Create motor variables\n";
        for (ItemData data : info.getMotors()) {
            rtn += "    DcMotor " + data.getProgramName() + ";\n";
        }

        rtn += "\n" +
                "    //Create servo variables\n";
        for (ItemData data : info.getServos()) {
            rtn += "    Servo " + data.getProgramName() + ";\n";
        }

        rtn += "\n";

        rtn += "    @Override\n" +
                "    public void runOpMode() throws InterruptedException {\n" +
                "        //Initialize motors and servos.\n";

        for (ItemData data : info.getMotors()) {
            rtn += "        " + data.getProgramName() + " = hardwareMap.dcMotor.get(\"" + data.getControllerName() + "\");\n";
            if (data.isReversed())
                rtn += "        " + data.getProgramName() + ".setDirection(DcMotor.Direction.REVERSE);\n";
            if (data.isDriveMotor())
                rtn += "        " + data.getProgramName() + ".setChannelMode(DcMotorController.RunMode.RUN_TO_POSITION);\n";
        }

        for (ItemData data : info.getServos()) {
            rtn += "        " + data.getProgramName() + " = hardwareMap.servo.get(\"" + data.getControllerName() + "\");\n";
            if (data.isReversed())
                rtn += "        " + data.getProgramName() + ".setDirection(Servo.Direction.REVERSE);\n";
        }

        rtn += "\n" +
                "        //Wait for the start button to be pressed\n" +
                "        waitForStart();\n" +
                "\n" +
                "        //Drive commands\n";
        PointArray points = info.getPointArray();

        if (!points.get(0).extraCode.equals("")) {
            rtn += "        " + points.get(0).extraCode + "\n";
        }
        for (int i = 0; i < points.size() - 2; i++) {
            rtn += "        autoDrive(" + points.getDistance(i) + ");\n";
            if (!points.get(i + 1).extraCode.equals("")) {
                rtn += "        " + points.get(i + 1).extraCode + "\n";
            }
            rtn += "\n" +
                    "        autoTurn(" + points.getAngle(i + 1) + ");\n";
        }

        rtn += "        autoDrive(" + points.getDistance(points.size() - 2) + ");\n";
        if (!points.get(points.size() - 1).extraCode.equals("")) {
            rtn += "        " + points.get(points.size() - 1).extraCode + "\n";
        }
        rtn += "    }\n\n";


        ItemData[] driveMotors = info.getDriveMotors();

        //defining autoDrive
        rtn += "    private void autoDrive(double inches) throws InterruptedException{\n" +
                "        int encoderCounts = (int)(inches/INCHES_PER_ROTATION*ENCODER_COUNTS_PER_ROTATION);\n" +
                "        //reset encoders\n";

        for (ItemData motor : driveMotors) {
            rtn += "        " + motor.getProgramName() + ".setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);\n";
        }

        rtn += "        waitForNextHardwareCycle();\n" +
                "        \n" +
                "        //set targets\n";
        for (ItemData motor : driveMotors) {
            rtn += "        " + motor.getProgramName() + ".setTargetPosition(encoderCounts);\n" +
                    "        " + motor.getProgramName() + ".setChannelMode(DcMotorController.RunMode.RUN_TO_POSITION);\n";
        }
        rtn += "        waitForNextHardwareCycle();\n" +
                "        \n" +
                "        //start motors with proper direction\n" +
                "        if (inches > 0) {\n";
        for (ItemData motor : driveMotors) {
            rtn += "            " + motor.getProgramName() + ".setPower(driveSpeed);\n";
        }
        rtn += "        } else {\n";
        for (ItemData motor : driveMotors) {
            rtn += "            " + motor.getProgramName() + ".setPower(-driveSpeed);\n";
        }
        rtn += "        }\n" +
                "        \n" +
                "        //wait for motors to reach positions\n" +
                "        while(";
        rtn += driveMotors[0].getProgramName() + ".getCurrentPosition() < encoderCounts";
        for (int i = 1; i < driveMotors.length; i++) {
            rtn += " || " + driveMotors[i].getProgramName() + ".getCurrentPosition() < encoderCounts";
        }
        rtn += ")\n" +
                "            waitOneFullHardwareCycle();\n" +
                "    }\n\n";

        //defining autoTurn
        rtn += "    private void autoTurn(double degrees) throws InterruptedException{\n" +
                "        int encoderCounts = (int)(ENCODER_COUNTS_PER_ROTATION/INCHES_PER_ROTATION*degrees*Math.PI/180*" + info.getDistanceBetweenWheels() / 2 + ");\n";
        for (ItemData motor : driveMotors) {
            rtn += "        " + motor.getProgramName() + ".setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);\n";
        }

        rtn += "        waitForNextHardwareCycle();\n" +
                "        \n" +
                "        //set targets\n";
        for (ItemData motor : driveMotors) {
            rtn += "        " + motor.getProgramName() + ".setTargetPosition(encoderCounts);\n" +
                    "        " + motor.getProgramName() + ".setChannelMode(DcMotorController.RunMode.RUN_TO_POSITION);\n";
        }
        rtn += "        waitForNextHardwareCycle();\n" +
                "        \n" +
                "        //start motors with proper direction\n" +
                "        if (degrees > 0) { //make sure to negate these as necessary so that the following code turns the robot clockwise\n";
        for (ItemData motor : driveMotors) {
            rtn += "            " + motor.getProgramName() + ".setPower(driveSpeed);\n";
        }
        rtn += "        } else {\n";
        for (ItemData motor : driveMotors) {
            rtn += "            " + motor.getProgramName() + ".setPower(-driveSpeed);\n";
        }
        rtn += "        }\n" +
                "        \n" +
                "        //wait for motors to reach positions\n" +
                "        while(";
        rtn += driveMotors[0].getProgramName() + ".getCurrentPosition() < encoderCounts";
        for (int i = 1; i < driveMotors.length; i++) {
            rtn += " || " + driveMotors[i].getProgramName() + ".getCurrentPosition() < encoderCounts";
        }
        rtn += ")\n" +
                "            waitOneFullHardwareCycle();\n" +
                "    }\n" +
                "}";

        return rtn;
    }

    public static void main(String[] args) {
        File file = FileChooser.fileChooser("Export", "Export", "Export this file");
        File save = FileChooser.fileChooser("Save Location", "Save", "Save file to this location");

        LinkedList<ItemData> servos = new LinkedList<ItemData>();
        LinkedList<ItemData> motors = new LinkedList<ItemData>();

        servos.add(new ItemData("arm", "servo_1"));
        servos.add(new ItemData("claw", "servo_6"));
        motors.add(new ItemData("left", "motor_1", false, true));
        motors.add(new ItemData("right", "motor_2", true, true));

        ProgramInfo info = new ProgramInfo(fileToPoints(file), file, "Test", servos, motors);
        ProgramInfo.gearRatio = 2;
        ProgramInfo.wheelDiameter = 4;
        ProgramInfo.distanceBetweenWheels = 17.5;

        try {
            PrintWriter writer = new PrintWriter(save);

            writer.print(writeLinearOpMode(info));
            writer.flush();
            writer.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}
